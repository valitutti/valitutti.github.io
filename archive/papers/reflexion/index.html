<!DOCTYPE html>

<html>
<head>
<title>Computational Reflexivity</title>


<style>

body { background:#e6ffe6 }

h1 { 
    color: #003300; 
    font: normal 33px Lucida Sans, Lucida Sans Unicode, Lucida Grande, sans-serif; 
    margin: 0; padding: 0; 
    line-height: 33px; letter-spacing: 8px; 
}
h1 span { font-variant: small-caps; letter-spacing:0.3em }
h1 span.upper { font-size:130%; }

h2 { 
    color: #003300; 
    font: normal 20px Lucida Sans, Lucida Sans Unicode, Lucida Grande, sans-serif; 
    margin: 0; padding: 0; 
    line-height: 33px; letter-spacing: 5px; 
}

h3 { 
    color: #003300; 
}

p { 
    color: #003300; 
    font: normal 14px Lucida Sans, Lucida Sans Unicode, Lucida Grande, sans-serif; 
    margin: 0; padding: 0; 
    line-height: 28px; letter-spacing: 0.6px; 
}
p span { font-variant: small-caps; letter-spacing:0em }
p span.upper { font-size:130%; }

pre { 
	font-family: monospace; 
	color: #0000b3;
	font-size:130%;
}


li { 
    color: #003300; 
    font: normal 14px Lucida Sans, Lucida Sans Unicode, Lucida Grande, sans-serif; 
    margin: 0; padding: 0; 
    line-height: 28px; letter-spacing: 0.6px; 
}
li span { font-variant: small-caps; letter-spacing:0em }
li span.upper { font-size:130%; }



</style>





</head>
<body>

<!---------------------------------------------------------------------------------->

<h1>Providing Self-Aware Systems with Reflexivity</h1>

<br>
<br>
<br>

<h2>Index</h2>

<ul>

	<li><a href="#appendix-a">Code Description</a></li>

	<li><a href="#appendix-b">Components of Computational Reflexion</a></li>

	<li><a href="#appendix-c">Lisp Code</a></li>

	<li><a href="#appendix-d">Examples of Execution</a></li>

	<li><a href="#tutorial">Tutorial</a></li>
	
	<li><a href="#overall">Overall code to copy, paste and run</a></li>

	<li><a href="#references">Notes</a></li>

	<li><a href="#references">References</a></li>
</ul>

<!---------------------------------------------------------------------------------->
<hr>

<a name="appendix-a"></a>
<h2>Code Description</h2>

<p>
We employed the code of an interpreter of the Lisp programming language, implemented in the same language, and called here <i>Lisp in Lisp</i>. Specifically, since the term <i>Lisp</i> is currently used to denote an entire family of programming languages sharing common characteristics, we tested and run the code in Common Lisp <a href="#Steele1990">(Steele, 1990)</a>. 



Rather than the original formulation of <tt>eval</tt> by McCarthy <a href="#McCarthy1960">(McCarthy, 1960)</a>, we adopted the simpler version by <a href="http://www.paulgraham.com/rootsoflisp.html">Paul Graham</a>, which also found a bug in the original version and removed it<a href="#note1"> [1]</a>.
</p>

<p>
In this context, we define <i>computational step</i> (and, equivalently, interpretation loop) as the <i>Lisp in Lisp</i> execution between two next calls of the <tt>eval</tt> function. Section <a href="#appendix-c">Lisp Code</a> contains
the code of the <i>Lisp in Lisp</i> (i.e., the <tt>eval.</tt> function) and its modified version (called <tt>eval-augment</tt>) implementing reflexion. 
</p>

<br>

<!---------------------------------------------------------------------------------->
<hr>

<a name="appendix-b"></a>
<h2>Components of Computational Reflexion</h2>

<p>
In the same way proceeded in the previous section, we focused on the interpretation loop and gradually enriched to obtain the version implementing computational reflexion.
</p>

<ol>

<li> <b>Lower Step</b>. It is equivalent to the interpretation loop defined above. </li>

<li> <b>Single (Local) Introspection</b>. The current <tt>eval</tt> call returns the code of the current instruction, consisting of a function call.</li>

<li> <b>Single Upper Step</b>. The code of the current function call, produced by the local introspection, is in turn executed (i.e. <tt>eval</tt> is called on it).</li>

<li> <b>Double Upper Step</b>.  The code generated by local introspection is enriched with additional instructions. As an example, we added a <tt>print</tt> call to the output of the current call. In this way, the interpreter will display on the terminal the trace of execution.</li>

<li> <b>Double Introspection</b>. Finally, the interpretation loop is enriched with the instruction for global introspection. In other words, it returns the code of the entire program.</li>
	
</ol>

<p>
In summary, at any stage of the computation, the interpreter accesses and executes the code both locally and globally. In particular, the program code could be modified at each step and, thus, influence the next execution.

As a specific example, Section "<a href="#appendix-d">Examples of Execution</a>" shows the Lisp definition of the function <tt>my-last</tt>, which gets a list as input and returns its last element as output.

</p>


<br>
<br>


<!---------------------------------------------------------------------------------->
<hr>

<a name="appendix-c"></a>
<h2>Lisp Code</h2>

<p>
The code of the function <tt>eval.</tt> corresponds to the version of the <i>Lisp in Lisp</i> by <a href="http://www.paulgraham.com/rootsoflisp.html">Paul Graham</a>.
We modified it and defined <tt>eval-augment}}</tt>, as a proof-of-concept version of the reflexive interpreter, with the following instruction: <center><pre><code>(augment input output pred)</code></pre></center>.
</p>

<p>
The function <tt>augment</tt> applies the predicate <tt>pred</tt> to the input and output of the current step. The specific implementation of <tt>pred</tt> in this example is <tt>*pred*</tt>, which extract the code of the current instruction and execute it again, thus performing the "mirroring" discussed in Section 3 of the paper.
</p>


<pre><code>
	
	
(defun eval. (e a)
  (cond
    ((atom e) (assoc. e a))
    ((atom (car e))
     (cond
       ((eq (car e) 'quote) (cadr e))
       ((eq (car e) 'atom)  (atom   (eval. (cadr e) a)))
       ((eq (car e) 'eq)    (eq     (eval. (cadr e) a)
                                    (eval. (caddr e) a)))
       ((eq (car e) 'car)   (car    (eval. (cadr e) a)))
       ((eq (car e) 'cdr)   (cdr    (eval. (cadr e) a)))
       ((eq (car e) 'cons)  (cons   (eval. (cadr e) a)
                                    (eval. (caddr e) a)))
       ((eq (car e) 'cond)  (evcon. (cdr e) a))
       ('t (eval. (cons (assoc. (car e) a)
                        (cdr e))
                  a))))
    ((eq (caar e) 'label)
     (eval. (cons (caddar e) (cdr e))
            (cons (list. (cadar e) (car e)) a)))
    ((eq (caar e) 'lambda)
     (eval. (caddar e)
            (append. (pair. (cadar e) (evlis. (cdr e) a))
                     a)))))

(defun null. (x)
  (eq x '()))

(defun and. (x y)
  (cond (x (cond (y 't) ('t '())))
        ('t '())))

(defun not. (x)
  (cond (x '())
        ('t 't)))

(defun append. (x y)
  (cond ((null. x) y)
        ('t (cons (car x) 
		  (append. (cdr x) y)))))

(defun list. (x y)
  (cons x (cons y '())))

(defun pair. (x y)
  (cond ((and. (null. x) (null. y)) '())
        ((and. (not. (atom x)) (not. (atom y)))
         (cons (list. (car x) (car y))
               (pair. (cdr x) (cdr y))))))

(defun assoc. (x y)
  (cond 
   ((null. y) '())
   ((eq (caar y) x) (cadar y))
   ('t (assoc. x (cdr y)))))

(defun evcon. (c a)
  (cond ((eval. (caar c) a)
         (eval. (cadar c) a))
        ('t (evcon. (cdr c) a))))

(defun evlis. (m a)
  (cond ((null. m) '())
        ('t (cons (eval.  (car m) a)
                  (evlis. (cdr m) a)))))

(defun eval-augment (e a pred)
  (let*
      ((input (list e a))
       (output
	(cond	
	 ((atom e) (assoc. e a))
	 ((atom (car e))
	  (cond
	   ((eq (car e) 'quote) (cadr e))
	   ((eq (car e) 'atom)  (atom   (eval-augment (cadr e) a pred)))
	   ((eq (car e) 'eq)    (eq     (eval-augment (cadr e) a pred)
					(eval-augment (caddr e) a pred)))
	   ((eq (car e) 'car)   (car    (eval-augment (cadr e) a pred)))
	   ((eq (car e) 'cdr)   (cdr    (eval-augment (cadr e) a pred)))
	   ((eq (car e) 'cons)  (cons   (eval-augment (cadr e) a pred)
					(eval-augment (caddr e) a pred)))
	   ((eq (car e) 'cond)  (evcon. (cdr e) a))
	   ('t (eval-augment (cons (assoc. (car e) a)
			    (cdr e))
		      a pred))))
	 ((eq (caar e) 'label)
	  (eval-augment (cons (caddar e) (cdr e))
		      (cons (list. (cadar e) (car e)) a) pred))
	 ((eq (caar e) 'lambda)
	  (eval-augment (caddar e)
		      (append. (pair. (cadar e) (evlis. (cdr e) a)) 
			       a) pred)))))
    (augment input output pred)
    output))


(defun augment (input output pred)
  (setq *done* (append *done* (list (list input output))))
  (funcall pred *done*))


(setq *pred* #'(lambda (done)
		  (let*
		      ((next (car (last done)))
		       (input (car next))
		       (e (car input))
		       (a (cadr input))
		       (output1 (eval. e a)))
		    (format t 
			    (concatenate 'string
				      (write-to-string input) "~%"
				      "-> " (write-to-string output1) "~%"))
		 t)))

</code></pre>



<!---------------------------------------------------------------------------------->
<hr>

<a name="appendix-d"></a>
<h2>Examples of Execution</h2>

<p>
As a simple example, the function <tt>augment</tt> and the predicate <tt>*pred*</tt> are applied to simple data (the atom <tt>a</tt> with value <tt>1</tt>, and the function <tt>car</tt> returning the first element of the list <tt>(a b)</tt>. In particular, it is applied to the simple recursive function <tt>my-last</tt>, returning the last element of a list.
</p>

<pre><code>

CL-USER(356): (eval-augment 'a '((a 1)) *pred2*)
1
CL-USER(357): (eval-augment 'a '((a 1)) *pred1*)
(A ((A 1)))
-> 1
1


CL-USER(360): (eval. '(car '(a b)) nil)
A
CL-USER(361): (eval-augment '(car '(a b)) nil *pred2*)
A
CL-USER(362): (eval-augment '(car '(a b)) nil *pred1*)
('(A B) NIL)
-> (A B)
((CAR '(A B)) NIL)
-> A
A


CL-USER(370): (setq e '(my-last '(a b c)))
(MY-LAST '(A B C))
CL-USER(371): (setq a '(
     (my-last (label my-last 
		     (lambda (x) 
		       (cond 
			((null. x) 'nil) 
			((null. (cdr x)) (car x)) 
			('t (my-last (cdr x)))
			)))) 
     (null. (label null. (lambda (x) (eq x nil))))
     ))
((MY-LAST (LABEL MY-LAST (LAMBDA (X) (COND # # #))))
 (NULL. (LABEL NULL. (LAMBDA (X) (EQ X NIL)))))
CL-USER(372): (eval. e a)
C
CL-USER(373): (eval-augment e a *pred2*)
C
CL-USER(374): (eval-augment e a *pred1*)
((COND ((NULL. X) 'NIL)
       ((NULL. (CDR X)) (CAR X))
       ('T (MY-LAST (CDR X))))
 ((X (A B C))
  (MY-LAST
   (LABEL MY-LAST
    (LAMBDA (X)
      (COND ((NULL. X) 'NIL)
            ((NULL. (CDR X)) (CAR X))
            ('T (MY-LAST (CDR X)))))))
  (MY-LAST
   (LABEL MY-LAST
    (LAMBDA (X)
      (COND ((NULL. X) 'NIL)
            ((NULL. (CDR X)) (CAR X))
            ('T (MY-LAST (CDR X)))))))
  (NULL. (LABEL NULL. (LAMBDA (X) (EQ X NIL))))))
-> C
(((LAMBDA (X)
    (COND ((NULL. X) 'NIL)
          ((NULL. (CDR X)) (CAR X))
          ('T (MY-LAST (CDR X)))))
  '(A B C))
 ((MY-LAST
   (LABEL MY-LAST
    (LAMBDA (X)
      (COND ((NULL. X) 'NIL)
            ((NULL. (CDR X)) (CAR X))
            ('T (MY-LAST (CDR X)))))))
  (MY-LAST
   (LABEL MY-LAST
    (LAMBDA (X)
      (COND ((NULL. X) 'NIL)
            ((NULL. (CDR X)) (CAR X))
            ('T (MY-LAST (CDR X)))))))
  (NULL. (LABEL NULL. (LAMBDA (X) (EQ X NIL))))))
-> C
(((LABEL MY-LAST
   (LAMBDA (X)
     (COND ((NULL. X) 'NIL)
           ((NULL. (CDR X)) (CAR X))
           ('T (MY-LAST (CDR X))))))
  '(A B C))
 ((MY-LAST
   (LABEL MY-LAST
    (LAMBDA (X)
      (COND ((NULL. X) 'NIL)
            ((NULL. (CDR X)) (CAR X))
            ('T (MY-LAST (CDR X)))))))
  (NULL. (LABEL NULL. (LAMBDA (X) (EQ X NIL))))))
-> C
((MY-LAST '(A B C))
 ((MY-LAST
   (LABEL MY-LAST
    (LAMBDA (X)
      (COND ((NULL. X) 'NIL)
            ((NULL. (CDR X)) (CAR X))
            ('T (MY-LAST (CDR X)))))))
  (NULL. (LABEL NULL. (LAMBDA (X) (EQ X NIL))))))
-> C
C

</code></pre>



<!---------------------------------------------------------------------------------->

<hr>
<a name="tutorial"></a>
<h2>Tutorial</h2>

<br>

<p>We suggest to use the <a href="http://rextester.com/l/common_lisp_online_compiler "target="_blank">Rextester</a> compiler. To load the code, copy and paste the above code in the <i>main.lisp</i> window and press <b>Execute</b>. To run the following instruction, copy them at the end of the code in the same window without running it. We added the <i>print</i> function in order to display the ouput with the compiler.</p>




<h3>Step 1: Some test instructions in Common Lisp</h3>

<p>Quoted expression with value <i>a</i>:</p>

<pre><code>
(print 'a)
</code></pre>

<p>First element of the list <i>(a b c)</i>:</p>

<pre><code>
(print (car '(a1 a2 a3)))
</code></pre>

<p>Sum of two numbers:</p>

<pre><code>
(print (+ 2 3))
</code></pre>




<h3>Step 2: Use of the system evaluator</h3>

<p>We apply the system <i>eval</i> function to the above expressions:</p>

<pre><code>
(print (eval ''a)) ; here the atomic expression "a" is quoted twice because of the 
                          ; evaluation of the read-eval-print loop and the second evaluation performed 
                          ; by the "eval" function

(setq a1 7) ; we set the atom "a1" to the value "7"

(print (eval (car '(a1 a2 a3))))
</code></pre>





<h3>Step 3: eval.</h3>

<p>Here we apply the function <i>eval.</i>, that is our defined evaluator. In this case, we need to specify the additional attribute with the list of associations:</p>

<pre><code>
(print (eval. ''a nil))

(print (eval. (car '(a1 a2 a3)) '((a1 8)) ))
</code></pre>



<h3>Step 4: eval-augment</h3>

<p></p>

<pre><code>

(print (eval-augment 'a '((a 1)) *pred2*))

(format 't "~%") ; print newline

(eval-augment 'a '((a 1)) *pred1*)

(print (eval. '(car '(a b)) nil))

(print (eval-augment '(car '(a b c)) nil *pred2*))

(format 't "~%~%") ; print newline

(eval-augment '(car '(a b)) nil *pred1*)

(eval-augment '1 nil *pred1*)

(print "---------------------------------------")
(format 't "~%")

(setq e '(my-last '(a b c)))

(print e)

(setq a '(
     (my-last (label my-last 
		     (lambda (x) 
		       (cond 
			((null. x) 'nil) 
			((null. (cdr x)) (car x)) 
			('t (my-last (cdr x)))
			)))) 
     (null. (label null. (lambda (x) (eq x nil))))
     ))
     
(print a)

(format 't "~%") ; print newline

(print (eval. e a))

(print (eval-augment e a *pred2*))

(format 't "~%") ; print newline

(eval-augment e a *pred1*)

</code></pre>

<!-- ------------------------------------------------------------------------------->
<hr>
<a name="overall"></a>

<h2>Overall code to copy, paste and run</h2>


<pre><code>

(print "loading the functions...")

(defun eval. (e a)
  (cond
    ((atom e) (assoc. e a))
    ((atom (car e))
     (cond
       ((eq (car e) 'quote) (cadr e))
       ((eq (car e) 'atom)  (atom   (eval. (cadr e) a)))
       ((eq (car e) 'eq)    (eq     (eval. (cadr e) a)
                                    (eval. (caddr e) a)))
       ((eq (car e) 'car)   (car    (eval. (cadr e) a)))
       ((eq (car e) 'cdr)   (cdr    (eval. (cadr e) a)))
       ((eq (car e) 'cons)  (cons   (eval. (cadr e) a)
                                    (eval. (caddr e) a)))
       ((eq (car e) 'cond)  (evcon. (cdr e) a))
       ('t (eval. (cons (assoc. (car e) a)
                        (cdr e))
                  a))))
    ((eq (caar e) 'label)
     (eval. (cons (caddar e) (cdr e))
            (cons (list. (cadar e) (car e)) a)))
    ((eq (caar e) 'lambda)
     (eval. (caddar e)
            (append. (pair. (cadar e) (evlis. (cdr e) a))
                     a)))))

(defun null. (x)
  (eq x '()))

(defun and. (x y)
  (cond (x (cond (y 't) ('t '())))
        ('t '())))

(defun not. (x)
  (cond (x '())
        ('t 't)))

(defun append. (x y)
  (cond ((null. x) y)
        ('t (cons (car x) 
		  (append. (cdr x) y)))))

(defun list. (x y)
  (cons x (cons y '())))

(defun pair. (x y)
  (cond ((and. (null. x) (null. y)) '())
        ((and. (not. (atom x)) (not. (atom y)))
         (cons (list. (car x) (car y))
               (pair. (cdr x) (cdr y))))))

(defun assoc. (x y)
  (cond 
   ((null. y) '())
   ((eq (caar y) x) (cadar y))
   ('t (assoc. x (cdr y)))))

(defun evcon. (c a)
  (cond ((eval. (caar c) a)
         (eval. (cadar c) a))
        ('t (evcon. (cdr c) a))))

(defun evlis. (m a)
  (cond ((null. m) '())
        ('t (cons (eval.  (car m) a)
                  (evlis. (cdr m) a)))))

(defun eval-augment (e a pred)
  (let*
      ((input (list e a))
       (output
	(cond	
	 ((atom e) (assoc. e a))
	 ((atom (car e))
	  (cond
	   ((eq (car e) 'quote) (cadr e))
	   ((eq (car e) 'atom)  (atom   (eval-augment (cadr e) a pred)))
	   ((eq (car e) 'eq)    (eq     (eval-augment (cadr e) a pred)
					(eval-augment (caddr e) a pred)))
	   ((eq (car e) 'car)   (car    (eval-augment (cadr e) a pred)))
	   ((eq (car e) 'cdr)   (cdr    (eval-augment (cadr e) a pred)))
	   ((eq (car e) 'cons)  (cons   (eval-augment (cadr e) a pred)
					(eval-augment (caddr e) a pred)))
	   ((eq (car e) 'cond)  (evcon. (cdr e) a))
	   ('t (eval-augment (cons (assoc. (car e) a)
			    (cdr e))
		      a pred))))
	 ((eq (caar e) 'label)
	  (eval-augment (cons (caddar e) (cdr e))
		      (cons (list. (cadar e) (car e)) a) pred))
	 ((eq (caar e) 'lambda)
	  (eval-augment (caddar e)
		      (append. (pair. (cadar e) (evlis. (cdr e) a)) 
			       a) pred)))))
    (augment input output pred)
    output))

(setq *done* nil)

(defun augment (input output pred)
  (setq *done* (append *done* (list (list input output))))
  (funcall pred *done*))


(setq *pred1* #'(lambda (done)
		  (let*
		      ((next (car (last done)))
		       (input (car next))
		       (e (car input))
		       (a (cadr input))
		       (output1 (eval. e a)))
		    (format t 
			    (concatenate 'string
				      (write-to-string input) "~%"
				      "-> " (write-to-string output1) "~%"))
		 t)))


(setq *pred2* #'(lambda (done)
		  (let*
		      ((next (car (last done)))
		       (input (car next))
		       (e (car input))
		       (a (cadr input))
		       (output1 (eval. e a)))
		    output1)))

;------------------------------------------------

(print "Functions loaded")


(print "Step 1: Some test instructions in Common Lisp")

(print 'a)

(print (car '(a1 a2 a3)))

(print (+ 2 3))

;------------------------------------------------

(print "Step 2: Use of the system evaluator")

(print (eval ''a)) ; here the atomic expression "a" is quoted twice because of the 
                          ; evaluation of the read-eval-print loop and the second evaluation performed 
                          ; by the "eval" function

(setq a1 7) ; we set the atom "a1" to the value "7"

(print (eval (car '(a1 a2 a3))))

;------------------------------------------------

(print "Step 3: eval.")

(print (eval. ''a nil))

(print (eval. (car '(a1 a2 a3)) '((a1 8)) ))

;------------------------------------------------

(print "Step 4: eval-augment")

(print (eval-augment 'a '((a 1)) *pred2*))

(format 't "~%") ; print newline

(eval-augment 'a '((a 1)) *pred1*)

(print (eval. '(car '(a b)) nil))

(print (eval-augment '(car '(a b c)) nil *pred2*))

(format 't "~%~%") ; print newline

(eval-augment '(car '(a b)) nil *pred1*)

(eval-augment '1 nil *pred1*)

(print "---------------------------------------")
(format 't "~%")

(setq e '(my-last '(a b c)))

(print e)

(setq a '(
     (my-last (label my-last 
		     (lambda (x) 
		       (cond 
			((null. x) 'nil) 
			((null. (cdr x)) (car x)) 
			('t (my-last (cdr x)))
			)))) 
     (null. (label null. (lambda (x) (eq x nil))))
     ))
     
(print a)

(format 't "~%") ; print newline

(print (eval. e a))

(print (eval-augment e a *pred2*))

(format 't "~%") ; print newline

(eval-augment e a *pred1*)

</code></pre>

<!---------------------------------------------------------------------------------->
<hr>

<a name="notes"></a>
<h2>Notes</h2>

<ul>

<li><a name="note1"></a>[1] We have found a small bug in Graham's code as well. In the definition body of the <tt>&lt;pair.&gt;</tt> function, there is a call to the <tt>&lt;list&gt;</tt> function, which is a system function. Since the set of primitive operators should not include <tt>&lt;list&gt;</tt>, we defined the function <tt>&lt;list.&gt;</tt> and used it to replace all the occurrences of <tt>&lt;list&gt;</tt> in the definition body of <tt>&lt;pair.&gt;</tt>. In this note, we rounded the function names with angular parenthesis to separate them more clearly from the rest of the text.</li>

</ul>

<br>


<!---------------------------------------------------------------------------------->
<hr>

<a name="references"></a>
<h2>References</h2>

<ul>


<li><a name="McCarthy1960"></a> J. McCarthy, Recursive functions of symbolic expressions and their computation by machine, part i, Communications of the ACM 3 (1960) 184â€“195.</li>

<li><a name="Steele1990"></a> G. L. Steele, Common Lisp the Language, 2nd Edition, Digital Press, 1990.</li>

</ul>




</body>
</html>